package machine;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Optional;
import java.util.stream.Stream;

public class TM {
	private String[][] input;
	private List<LinkedList<String>> Tapes = new ArrayList<LinkedList<String>>();
	private int[] iterators;
	private List<String> alphabet;
	private List<String> inner_alphabet;
	private States states;
	private Instruction[] instructions;
	private String current_state;
	
	
	public TM(
			int numOfTapes,
			String[][] input,
			List<String> alphabet,
			States states,
			Instruction[] instructions)
	{
		this.alphabet = alphabet;
		this.inner_alphabet = alphabet.subList(0, alphabet.size());
		inner_alphabet.add("#"); //Начало строки
		inner_alphabet.add("B"); //Blank
		this.states = states;
		this.instructions = instructions;
		this.current_state = states.start();
		this.input = input;
		this.iterators = new int[numOfTapes];
		for(int i = 0; i<numOfTapes; i++) {
			iterators[i]++; //указывает наа первый элемент входа
			Tapes.add(new LinkedList<String>());
			Tapes.get(i).add("#"); //начало строки
			for(int j = 0; j < input[i].length; j++) {
				Tapes.get(i).add(input[i][j]);
			}
			Tapes.get(i).add("B"); //конец строки
		}
		
	}
	
	public List<LinkedList<String>> executeProgram() throws NoSuchInstruction {
		do {
			Optional<Instruction> todo = Arrays.stream(instructions).filter(instr -> isRequiredInstruction(instr)).findFirst();
			if (todo.isPresent()) {
				current_state = iterate(todo.get());
			}
			else { 
				throw new NoSuchInstruction(getCurrentInstruction());
			}
				
		} while(current_state != states.end());
		return Tapes;
	}

	private String iterate(Instruction todo) { //выполнение инструкции
		for(int i = 0; i < iterators.length; i++) {
			Tapes.get(i).set(iterators[i], todo.output_symbols[i]); //смена состояний
			switch(todo.move[i]) { //сдвиг указателейй
				case L:
					iterators[i]--;
					break;
				case R:
					iterators[i]++;
					if(iterators[i] == Tapes.get(i).size()) Tapes.get(i).add("B"); //самоудлинение
					break;
				default:
					break;
			}
		}
		return todo.new_state;
	}

	private boolean isRequiredInstruction(Instruction i) { //поиск подходящей инструкции
		boolean matches = true;
		for(int j = 0; j < iterators.length; j++) {
			if (!i.input_symbols[j].equals(Tapes.get(j).get(iterators[j]))) {
				matches = false;
			}
		}
		if(!i.start_state.equals(current_state)) {
			matches = false;
		}
		return matches;
	}
	
	public Instruction getCurrentInstruction() {
		String[] inp_sym = new String[iterators.length];
		for(int j = 0; j < iterators.length; j++) {
			inp_sym[j] = Tapes.get(j).get(iterators[j]);
		}
		return new Instruction(current_state, inp_sym, null, null, null);
	}
}
			